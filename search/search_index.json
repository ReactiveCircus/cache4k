{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cache4k","text":"<p>In-memory Cache for Kotlin Multiplatform.</p> <p>Work in progress.</p> <p>cache4k provides a simple in-memory key-value cache for Kotlin Multiplatform, with support for time-based (expiration) and size-based evictions.</p> <p>Note that only the new Kotlin Native memory model is supported.</p> <p>The following targets are currently supported:</p> <ul> <li>jvm</li> <li>js</li> <li>iosX64</li> <li>iosArm64</li> <li>iosSimulatorArm64</li> <li>macosX64</li> <li>macosArm64</li> <li>tvosArm64</li> <li>tvosSimulatorArm64</li> <li>tvosX64</li> <li>watchosArm64</li> <li>watchosSimulatorArm64</li> <li>watchosX64</li> <li>linuxX64</li> <li>mingwX64</li> </ul>"},{"location":"#download","title":"Download","text":"<p>Dependencies are hosted on Maven Central.</p>"},{"location":"#android","title":"Android","text":"<pre><code>dependencies {\nimplementation(\"io.github.reactivecircus.cache4k:cache4k:x.y.z\")\n}\n</code></pre>"},{"location":"#multiplatform","title":"Multiplatform","text":"<pre><code>kotlin {\nsourceSets {\ncommonMain {\ndependencies {\nimplementation(\"io.github.reactivecircus.cache4k:cache4k:x.y.z\")\n}\n}\n}\n}\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#writing-and-reading-cache-entries","title":"Writing and reading cache entries","text":"<p>To create a new <code>Cache</code> instance using <code>Long</code> for the key and <code>String</code> for the value:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;().build()\n</code></pre> <p>To start writing entries to the cache:</p> <pre><code>cache.put(1, \"dog\")\ncache.put(2, \"cat\")\n</code></pre> <p>To read a cache entry by key:</p> <pre><code>cache.get(1) // returns \"dog\"\ncache.get(2) // returns \"cat\"\ncache.get(3) // returns null\n</code></pre> <p>To overwrite an existing cache entry:</p> <pre><code>cache.put(1, \"dog\")\ncache.put(1, \"bird\")\ncache.get(1) // returns \"bird\"\n</code></pre>"},{"location":"#cache-loader","title":"Cache loader","text":"<p>Cache provides an API for getting cached value by key and using the provided <code>loader: suspend () -&gt; Value</code> lambda to compute and cache the value automatically if none exists.</p> <pre><code>runBlockingTest {\nval cache = Cache.Builder&lt;Long, User&gt;().build()\n\nval userId = 1L\nval user = cache.get(userId) {\nfetchUserById(userId) // potentially expensive call (might be a suspend function)\n}\n\n// value successfully computed by the loader will be cached automatically\nassertThat(user).isEqualTo(cache.get(userId))\n}\n</code></pre> <p>Note that loader is executed on the caller\u2019s coroutine context. Concurrent calls from multiple threads using the same key will be blocked. Assuming the 1st call successfully computes a new value, none of the loader from the other calls will be executed and the cached value computed by the first loader will be returned for those calls.</p> <p>Any exceptions thrown by the <code>loader</code> will be propagated to the caller of this function.</p>"},{"location":"#expirations-and-evictions","title":"Expirations and evictions","text":"<p>By default, Cache has an unlimited number of entries which never expire. But a cache can be configured to support both time-based expirations and size-based evictions.</p>"},{"location":"#time-based-expiration","title":"Time-based expiration","text":"<p>Expiration time can be specified for entries in the cache.</p>"},{"location":"#expire-after-access","title":"Expire after access","text":"<p>To set the maximum time an entry can live in the cache since the last access (also known as ** time-to-idle**), where \u201caccess\u201d means reading the cache, adding a new cache entry, or ** replacing an existing entry with a new one**:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;()\n.expireAfterAccess(24.hours)\n.build()\n</code></pre> <p>An entry in this cache will be removed if it has not been read or replaced after 24 hours since it\u2019s been written into the cache.</p>"},{"location":"#expire-after-write","title":"Expire after write","text":"<p>To set the maximum time an entry can live in the cache since the last write (also known as ** time-to-live**), where \u201cwrite\u201d means adding a new cache entry or replacing an existing entry with a new one:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;()\n.expireAfterWrite(30.minutes)\n.build()\n</code></pre> <p>An entry in this cache will be removed if it has not been replaced after 30 minutes since it\u2019s been written into the cache.</p> <p>Note that cache entries are not removed immediately upon expiration at exact time. Expirations are checked in each interaction with the <code>cache</code>.</p>"},{"location":"#size-based-eviction","title":"Size-based eviction","text":"<p>To set the maximum number of entries to be kept in the cache:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;()\n.maximumCacheSize(100)\n.build()\n</code></pre> <p>Once there are more than 100 entries in this cache, the least recently used one will be removed, where \u201cused\u201d means reading the cache, adding a new cache entry, or replacing an existing entry with a new one.</p>"},{"location":"#getting-all-cache-entries-as-a-map","title":"Getting all cache entries as a Map","text":"<p>To get a copy of the current cache entries as a <code>Map</code>:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;()\n.build()\n\ncache.put(1, \"dog\")\ncache.put(2, \"cat\")\n\nassertThat(cache.asMap())\n.isEqualTo(mapOf(1L to \"dog\", 2L to \"cat\"))\n</code></pre> <p>Note that calling <code>asMap()</code> has no effect on the access expiry of the cache.</p>"},{"location":"#deleting-cache-entries","title":"Deleting cache entries","text":"<p>Cache entries can also be deleted explicitly.</p> <p>To delete a cache entry for a given key:</p> <pre><code>val cache = Cache.Builder&lt;Long, String&gt;().build()\ncache.put(1, \"dog\")\n\ncache.invalidate(1)\n\nassertThat(cache.get(1)).isNull()\n</code></pre> <p>To delete all entries in the cache:</p> <pre><code>cache.invalidateAll()\n</code></pre>"},{"location":"#event-listener","title":"Event listener","text":"<p>You can set an event listener as a lambda:</p> <pre><code>val cache1 = Cache.Builder&lt;Long, String&gt;()\n.eventListener { event -&gt;\nprintln(\"onEvent: $event\")\n}\n.build()\n</code></pre> <p>Or declare it as a class and share logic across many stores:</p> <pre><code>class FileDeleteEventListener : CacheEventListener&lt;Long, File&gt; {\noverride fun onEvent(event: CacheEvent&lt;Long, File&gt;) {\nwhen(event) {\nis CacheEvent.Created -&gt; {}\nis CacheEvent.Updated -&gt; event.oldValue.delete()\nis CacheEvent.Evicted -&gt; event.value.delete()\nis CacheEvent.Expired -&gt; event.value.delete()\nis CacheEvent.Removed -&gt; event.value.delete()\n}\n}\n}\nval fileDeleteEventListener = FileDeleteEventListener()\n\nval cache1 = Cache.Builder&lt;Long, File&gt;()\n.eventListener(fileDeleteEventListener)\n.build()\n\nval cache2 = Cache.Builder&lt;Long, File&gt;()\n.eventListener(fileDeleteEventListener)\n.build()\n</code></pre> <p>Cache entry event firing behaviors for mutative methods:</p> Initial value Operation New value Event {} put(K, V) {K: V} Created(K, V) {K: V1} put(K, V2) {K: V2} Updated(K, V1, V2) {K: V} invalidate(K) {} Removed(K, V) {K1: V1, K2: V2} invalidateAll() {} Removed(K1, V1), Removed(K2, V2) {K: V} any operation, K expired {} Expired(K, V) {K1: V1} put(K2, V2), K1 evicted {K2: V2} Created(K2, V2), Evicted(K1, V1)"},{"location":"#unit-testing-cache-expirations","title":"Unit testing cache expirations","text":"<p>To test logic that depends on cache expiration, pass in a <code>FakeTimeSource</code> when building a <code>Cache</code> so you can programmatically advance the reading of the time source:</p> <pre><code>@Test\nfun cacheEntryEvictedAfterExpiration() {\nprivate val fakeTimeSource = FakeTimeSource()\nval cache = Cache.Builder&lt;Long, String&gt;()\n.timeSource(fakeTimeSource)\n.expireAfterWrite(1.minutes)\n.build()\n\ncache.put(1, \"dog\")\n\n// just before expiry\nfakeTimeSource += 1.minutes - 1.nanoseconds\n\nassertThat(cache.get(1))\n.isEqualTo(\"dog\")\n\n// now expires\nfakeTimeSource += 1.nanoseconds\n\nassertThat(cache.get(1))\n.isNull()\n}\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>The library was ported from a kotlin / JVM cache which I contributed to dropbox/Store to help unblock Store\u2019s multiplatform support ( it was reverted before the 1.0 release as multiplatform wasn\u2019t a priority). Many thanks to Store\u2019s owners and contributors for reviewing and improving the original implementation.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2021 Yang Chen\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler, YourKit .NET Profiler, and YourKit YouMonitor.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#0110","title":"0.11.0","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New event listener APIs (@darkxanter) - 35</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Downgrade stately to 1.2.5 to fix duplicate class error - 36</li> </ul>"},{"location":"changelog/#0100","title":"0.10.0","text":""},{"location":"changelog/#added_1","title":"Added","text":"<p>Added new targets: - <code>watchosArm64</code> - <code>watchosSimulatorArm64</code> - <code>watchosX64</code></p> <p><code>FakeTimeSource</code> is now public - #30</p>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Kotlin 1.8.20.</li> <li>AtomicFU 0.20.2.</li> <li>Stately 2.0.0-rc1.</li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Revert to using <code>state-collections</code> to fix JVM concurrency issue - #23</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Kotlin 1.7.20.</li> <li>AtomicFU 0.18.5.</li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":""},{"location":"changelog/#added_2","title":"Added","text":"<p>Added new targets: - <code>linuxX64</code> - <code>macosArm64</code></p>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Kotlin 1.7.10.</li> <li>Coroutines 1.6.4.</li> <li>AtomicFU 0.18.3.</li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Kotlin 1.7.0.</li> <li>Coroutines 1.6.3.</li> <li>AtomicFU 0.18.2.</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li><code>fakeTimeSource</code> in <code>Cache.Builder</code> has been renamed to <code>timeSource</code>, and the <code>FakeTimeSource</code> implementation has been removed (still available in our tests) - #20</li> <li>Kotlin 1.6.21.</li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>This release adds support for new native memory model and drops support for the old one. Many thanks to @dcvz for the contribution. </p>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Synchronize cache loader by key - #15</li> <li>Support new native memory model and drop support for old memory model - #17</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Kotlin 1.6.20.</li> <li>Coroutines 1.6.1.</li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":""},{"location":"changelog/#added_4","title":"Added","text":"<p>Added new targets: - <code>iosSimulatorArm64</code> - <code>macosArm64</code> - <code>tvosArm64</code>  - <code>tvosSimulatorArm64</code> - <code>tvosX64</code></p>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Kotlin 1.6.10.</li> <li>Stately 1.2.1.</li> <li>Target Java 11.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Change <code>fun newBuilder()</code> to <code>operator fun invoke()</code> - #7.</li> <li>Compile with Kotlin 1.5.21.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Support Kotlin 1.5.0.</li> <li>Stately to 1.1.7.</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Disable IR.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Initial release.</p>"}]}
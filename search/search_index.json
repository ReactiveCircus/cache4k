{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cache4k \u00b6 In-memory Cache for Kotlin Multiplatform. Work in progress. cache4k provides a simple in-memory key-value cache for Kotlin Multiplatform , with support for time-based (expiration) and size-based evictions. Note that only the new Kotlin Native memory model is supported. The following targets are currently supported: jvm js iosX64 iosArm64 iosSimulatorArm64 macosX64 macosArm64 tvosArm64 tvosSimulatorArm64 tvosX64 linuxX64 mingwX64 Download \u00b6 Dependencies are hosted on Maven Central . Android \u00b6 dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } Multiplatform \u00b6 kotlin { sourceSets { commonMain { dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } } } } Usage \u00b6 Writing and reading cache entries \u00b6 To create a new Cache instance using Long for the key and String for the value: val cache = Cache . Builder (). build < Long , String > () To start writing entries to the cache: cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) To read a cache entry by key: cache . get ( 1 ) // returns \"dog\" cache . get ( 2 ) // returns \"cat\" cache . get ( 3 ) // returns null To overwrite an existing cache entry: cache . put ( 1 , \"dog\" ) cache . put ( 1 , \"bird\" ) cache . get ( 1 ) // returns \"bird\" Cache loader \u00b6 Cache provides an API for getting cached value by key and using the provided loader: suspend () -> Value lambda to compute and cache the value automatically if none exists. runBlockingTest { val cache = Cache . Builder (). build < Long , User > () val userId = 1L val user = cache . get ( userId ) { fetchUserById ( userId ) // potentially expensive call (might be a suspend function) } // value successfully computed by the loader will be cached automatically assertThat ( user ). isEqualTo ( cache . get ( userId )) } Note that loader is executed on the caller\u2019s coroutine context. Concurrent calls from multiple threads using the same key will be blocked. Assuming the 1 st call successfully computes a new value, none of the loader from the other calls will be executed and the cached value computed by the first loader will be returned for those calls. Any exceptions thrown by the loader will be propagated to the caller of this function. Expirations and evictions \u00b6 By default, Cache has an unlimited number of entries which never expire. But a cache can be configured to support both time-based expirations and size-based evictions . Time-based expiration \u00b6 Expiration time can be specified for entries in the cache. Expire after access \u00b6 To set the maximum time an entry can live in the cache since the last access (also known as ** time-to-idle**), where \u201caccess\u201d means reading the cache , adding a new cache entry , or ** replacing an existing entry with a new one**: val cache = Cache . Builder () . expireAfterAccess ( 24. hours ) . build < Long , String > () An entry in this cache will be removed if it has not been read or replaced after 24 hours since it\u2019s been written into the cache. Expire after write \u00b6 To set the maximum time an entry can live in the cache since the last write (also known as ** time-to-live**), where \u201cwrite\u201d means adding a new cache entry or replacing an existing entry with a new one : val cache = Cache . Builder () . expireAfterWrite ( 30. minutes ) . build < Long , String > () An entry in this cache will be removed if it has not been replaced after 30 minutes since it\u2019s been written into the cache. Note that cache entries are not removed immediately upon expiration at exact time. Expirations are checked in each interaction with the cache . Size-based eviction \u00b6 To set the maximum number of entries to be kept in the cache: val cache = Cache . Builder () . maximumCacheSize ( 100 ) . build < Long , String > () Once there are more than 100 entries in this cache, the least recently used one will be removed, where \u201cused\u201d means reading the cache , adding a new cache entry , or replacing an existing entry with a new one . Getting all cache entries as a Map \u00b6 To get a copy of the current cache entries as a Map : val cache = Cache . Builder () . build < Long , String > () cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) assertThat ( cache . asMap ()) . isEqualTo ( mapOf ( 1L to \"dog\" , 2L to \"cat\" )) Note that calling asMap() has no effect on the access expiry of the cache. Deleting cache entries \u00b6 Cache entries can also be deleted explicitly. To delete a cache entry for a given key: val cache = Cache . Builder (). build < Long , String > () cache . put ( 1 , \"dog\" ) cache . invalidate ( 1 ) assertThat ( cache . get ( 1 )). isNull () To delete all entries in the cache: cache . invalidateAll () Unit testing cache expirations \u00b6 To test logic that depends on cache expiration, pass in a fake TimeSource implementation when building a Cache so you can programmatically advance the reading of the time source: @Test fun cacheEntryEvictedAfterExpiration () { private val fakeTimeSource = FakeTimeSource () val cache = Cache . Builder () . timeSource ( fakeTimeSource ) . expireAfterWrite ( 1. minutes ) . build < Long , String > () cache . put ( 1 , \"dog\" ) // just before expiry fakeTimeSource += 1. minutes - 1. nanoseconds assertThat ( cache . get ( 1 )) . isEqualTo ( \"dog\" ) // now expires fakeTimeSource += 1. nanoseconds assertThat ( cache . get ( 1 )) . isNull () } A sample FakeTimeSource implementation can be found in our tests . Credits \u00b6 The library was ported from a kotlin / JVM cache which I contributed to dropbox/Store to help unblock Store\u2019s multiplatform support ( it was reverted before the 1.0 release as multiplatform wasn\u2019t a priority). Many thanks to Store\u2019s owners and contributors for reviewing and improving the original implementation. License \u00b6 Copyright 2021 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#cache4k","text":"In-memory Cache for Kotlin Multiplatform. Work in progress. cache4k provides a simple in-memory key-value cache for Kotlin Multiplatform , with support for time-based (expiration) and size-based evictions. Note that only the new Kotlin Native memory model is supported. The following targets are currently supported: jvm js iosX64 iosArm64 iosSimulatorArm64 macosX64 macosArm64 tvosArm64 tvosSimulatorArm64 tvosX64 linuxX64 mingwX64","title":"cache4k"},{"location":"#download","text":"Dependencies are hosted on Maven Central .","title":"Download"},{"location":"#android","text":"dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) }","title":"Android"},{"location":"#multiplatform","text":"kotlin { sourceSets { commonMain { dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } } } }","title":"Multiplatform"},{"location":"#usage","text":"","title":"Usage"},{"location":"#writing-and-reading-cache-entries","text":"To create a new Cache instance using Long for the key and String for the value: val cache = Cache . Builder (). build < Long , String > () To start writing entries to the cache: cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) To read a cache entry by key: cache . get ( 1 ) // returns \"dog\" cache . get ( 2 ) // returns \"cat\" cache . get ( 3 ) // returns null To overwrite an existing cache entry: cache . put ( 1 , \"dog\" ) cache . put ( 1 , \"bird\" ) cache . get ( 1 ) // returns \"bird\"","title":"Writing and reading cache entries"},{"location":"#cache-loader","text":"Cache provides an API for getting cached value by key and using the provided loader: suspend () -> Value lambda to compute and cache the value automatically if none exists. runBlockingTest { val cache = Cache . Builder (). build < Long , User > () val userId = 1L val user = cache . get ( userId ) { fetchUserById ( userId ) // potentially expensive call (might be a suspend function) } // value successfully computed by the loader will be cached automatically assertThat ( user ). isEqualTo ( cache . get ( userId )) } Note that loader is executed on the caller\u2019s coroutine context. Concurrent calls from multiple threads using the same key will be blocked. Assuming the 1 st call successfully computes a new value, none of the loader from the other calls will be executed and the cached value computed by the first loader will be returned for those calls. Any exceptions thrown by the loader will be propagated to the caller of this function.","title":"Cache loader"},{"location":"#expirations-and-evictions","text":"By default, Cache has an unlimited number of entries which never expire. But a cache can be configured to support both time-based expirations and size-based evictions .","title":"Expirations and evictions"},{"location":"#time-based-expiration","text":"Expiration time can be specified for entries in the cache.","title":"Time-based expiration"},{"location":"#expire-after-access","text":"To set the maximum time an entry can live in the cache since the last access (also known as ** time-to-idle**), where \u201caccess\u201d means reading the cache , adding a new cache entry , or ** replacing an existing entry with a new one**: val cache = Cache . Builder () . expireAfterAccess ( 24. hours ) . build < Long , String > () An entry in this cache will be removed if it has not been read or replaced after 24 hours since it\u2019s been written into the cache.","title":"Expire after access"},{"location":"#expire-after-write","text":"To set the maximum time an entry can live in the cache since the last write (also known as ** time-to-live**), where \u201cwrite\u201d means adding a new cache entry or replacing an existing entry with a new one : val cache = Cache . Builder () . expireAfterWrite ( 30. minutes ) . build < Long , String > () An entry in this cache will be removed if it has not been replaced after 30 minutes since it\u2019s been written into the cache. Note that cache entries are not removed immediately upon expiration at exact time. Expirations are checked in each interaction with the cache .","title":"Expire after write"},{"location":"#size-based-eviction","text":"To set the maximum number of entries to be kept in the cache: val cache = Cache . Builder () . maximumCacheSize ( 100 ) . build < Long , String > () Once there are more than 100 entries in this cache, the least recently used one will be removed, where \u201cused\u201d means reading the cache , adding a new cache entry , or replacing an existing entry with a new one .","title":"Size-based eviction"},{"location":"#getting-all-cache-entries-as-a-map","text":"To get a copy of the current cache entries as a Map : val cache = Cache . Builder () . build < Long , String > () cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) assertThat ( cache . asMap ()) . isEqualTo ( mapOf ( 1L to \"dog\" , 2L to \"cat\" )) Note that calling asMap() has no effect on the access expiry of the cache.","title":"Getting all cache entries as a Map"},{"location":"#deleting-cache-entries","text":"Cache entries can also be deleted explicitly. To delete a cache entry for a given key: val cache = Cache . Builder (). build < Long , String > () cache . put ( 1 , \"dog\" ) cache . invalidate ( 1 ) assertThat ( cache . get ( 1 )). isNull () To delete all entries in the cache: cache . invalidateAll ()","title":"Deleting cache entries"},{"location":"#unit-testing-cache-expirations","text":"To test logic that depends on cache expiration, pass in a fake TimeSource implementation when building a Cache so you can programmatically advance the reading of the time source: @Test fun cacheEntryEvictedAfterExpiration () { private val fakeTimeSource = FakeTimeSource () val cache = Cache . Builder () . timeSource ( fakeTimeSource ) . expireAfterWrite ( 1. minutes ) . build < Long , String > () cache . put ( 1 , \"dog\" ) // just before expiry fakeTimeSource += 1. minutes - 1. nanoseconds assertThat ( cache . get ( 1 )) . isEqualTo ( \"dog\" ) // now expires fakeTimeSource += 1. nanoseconds assertThat ( cache . get ( 1 )) . isNull () } A sample FakeTimeSource implementation can be found in our tests .","title":"Unit testing cache expirations"},{"location":"#credits","text":"The library was ported from a kotlin / JVM cache which I contributed to dropbox/Store to help unblock Store\u2019s multiplatform support ( it was reverted before the 1.0 release as multiplatform wasn\u2019t a priority). Many thanks to Store\u2019s owners and contributors for reviewing and improving the original implementation.","title":"Credits"},{"location":"#license","text":"Copyright 2021 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 0.9.0 \u00b6 Fixed \u00b6 Revert to using state-collections to fix JVM concurrency issue - #23 Changed \u00b6 Kotlin 1.7.20. AtomicFU 0.18.5. 0.8.0 \u00b6 Added \u00b6 Added new targets: - linuxX64 - macosArm64 Changed \u00b6 Kotlin 1.7.10. Coroutines 1.6.4. AtomicFU 0.18.3. 0.7.0 \u00b6 Changed \u00b6 Kotlin 1.7.0. Coroutines 1.6.3. AtomicFU 0.18.2. 0.6.0 \u00b6 Changed \u00b6 fakeTimeSource in Cache.Builder has been renamed to timeSource , and the FakeTimeSource implementation has been removed (still available in our tests) - #20 Kotlin 1.6.21. 0.5.0 \u00b6 This release adds support for new native memory model and drops support for the old one. Many thanks to @dcvz for the contribution. Added \u00b6 Synchronize cache loader by key - #15 Support new native memory model and drop support for old memory model - #17 Changed \u00b6 Kotlin 1.6.20. Coroutines 1.6.1. 0.4.0 \u00b6 Added \u00b6 Added new targets: - iosSimulatorArm64 - macosArm64 - tvosArm64 - tvosSimulatorArm64 - tvosX64 Changed \u00b6 Kotlin 1.6.10. Stately 1.2.1. Target Java 11. 0.3.0 \u00b6 Changed \u00b6 Change fun newBuilder() to operator fun invoke() - #7 . Compile with Kotlin 1.5.21. 0.2.0 \u00b6 Changed \u00b6 Support Kotlin 1.5.0. Stately to 1.1.7. 0.1.1 \u00b6 Changed \u00b6 Disable IR. 0.1.0 \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#090","text":"","title":"0.9.0"},{"location":"changelog/#fixed","text":"Revert to using state-collections to fix JVM concurrency issue - #23","title":"Fixed"},{"location":"changelog/#changed","text":"Kotlin 1.7.20. AtomicFU 0.18.5.","title":"Changed"},{"location":"changelog/#080","text":"","title":"0.8.0"},{"location":"changelog/#added","text":"Added new targets: - linuxX64 - macosArm64","title":"Added"},{"location":"changelog/#changed_1","text":"Kotlin 1.7.10. Coroutines 1.6.4. AtomicFU 0.18.3.","title":"Changed"},{"location":"changelog/#070","text":"","title":"0.7.0"},{"location":"changelog/#changed_2","text":"Kotlin 1.7.0. Coroutines 1.6.3. AtomicFU 0.18.2.","title":"Changed"},{"location":"changelog/#060","text":"","title":"0.6.0"},{"location":"changelog/#changed_3","text":"fakeTimeSource in Cache.Builder has been renamed to timeSource , and the FakeTimeSource implementation has been removed (still available in our tests) - #20 Kotlin 1.6.21.","title":"Changed"},{"location":"changelog/#050","text":"This release adds support for new native memory model and drops support for the old one. Many thanks to @dcvz for the contribution.","title":"0.5.0"},{"location":"changelog/#added_1","text":"Synchronize cache loader by key - #15 Support new native memory model and drop support for old memory model - #17","title":"Added"},{"location":"changelog/#changed_4","text":"Kotlin 1.6.20. Coroutines 1.6.1.","title":"Changed"},{"location":"changelog/#040","text":"","title":"0.4.0"},{"location":"changelog/#added_2","text":"Added new targets: - iosSimulatorArm64 - macosArm64 - tvosArm64 - tvosSimulatorArm64 - tvosX64","title":"Added"},{"location":"changelog/#changed_5","text":"Kotlin 1.6.10. Stately 1.2.1. Target Java 11.","title":"Changed"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changed_6","text":"Change fun newBuilder() to operator fun invoke() - #7 . Compile with Kotlin 1.5.21.","title":"Changed"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changed_7","text":"Support Kotlin 1.5.0. Stately to 1.1.7.","title":"Changed"},{"location":"changelog/#011","text":"","title":"0.1.1"},{"location":"changelog/#changed_8","text":"Disable IR.","title":"Changed"},{"location":"changelog/#010","text":"Initial release.","title":"0.1.0"}]}
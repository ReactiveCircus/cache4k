{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cache4k \u00b6 In-memory Cache for Kotlin Multiplatform. Work in progress. cache4k provides a simple in-memory key-value cache for Kotlin Multiplatform , with support for time-based (expiration) and size-based evictions. The following targets are currently supported: jvm js iosX64 iosArm64 macosX64 watchosArm32 watchosArm64 tvosX64 tvosArm64 Download \u00b6 Dependencies are hosted on Maven Central . Android \u00b6 dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } Multiplatform \u00b6 kotlin { sourceSets { commonMain { dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } } } } Usage \u00b6 Writing and reading cache entries \u00b6 To create a new Cache instance using Long for the key and String for the value: val cache = Cache . Builder (). build < Long , String > () To start writing entries to the cache: cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) To read a cache entry by key: cache . get ( 1 ) // returns \"dog\" cache . get ( 2 ) // returns \"cat\" cache . get ( 3 ) // returns null To overwrite an existing cache entry: cache . put ( 1 , \"dog\" ) cache . put ( 1 , \"bird\" ) cache . get ( 1 ) // returns \"bird\" Cache loader \u00b6 Cache provides an API for getting cached value by key and using the provided loader: suspend () -> Value lambda to compute and cache the value automatically if none exists. runBlockingTest { val cache = Cache . Builder (). build < Long , User > () val userId = 1L val user = cache . get ( userId ) { fetchUserById ( userId ) // potentially expensive call (might be a suspend function) } // value successfully computed by the loader will be cached automatically assertThat ( user ). isEqualTo ( cache . get ( userId )) } Any exceptions thrown by the loader will be propagated to the caller of this function. Expirations and evictions \u00b6 By default, Cache has an unlimited number of entries which never expire. But a cache can be configured to support both time-based expirations and size-based evictions . Time-based expiration \u00b6 Expiration time can be specified for entries in the cache. Expire after access \u00b6 To set the maximum time an entry can live in the cache since the last access (also known as ** time-to-idle**), where \u201caccess\u201d means reading the cache , adding a new cache entry , or ** replacing an existing entry with a new one**: val cache = Cache . Builder () . expireAfterAccess ( 24. hours ) . build < Long , String > () An entry in this cache will be removed if it has not been read or replaced after 24 hours since it\u2019s been written into the cache. Expire after write \u00b6 To set the maximum time an entry can live in the cache since the last write (also known as ** time-to-live**), where \u201cwrite\u201d means adding a new cache entry or replacing an existing entry with a new one : val cache = Cache . Builder () . expireAfterWrite ( 30. minutes ) . build < Long , String > () An entry in this cache will be removed if it has not been replaced after 30 minutes since it\u2019s been written into the cache. Note that cache entries are not removed immediately upon expiration at exact time. Expirations are checked in each interaction with the cache . Size-based eviction \u00b6 To set the maximum number of entries to be kept in the cache: val cache = Cache . Builder () . maximumCacheSize ( 100 ) . build < Long , String > () Once there are more than 100 entries in this cache, the least recently used one will be removed, where \u201cused\u201d means reading the cache , adding a new cache entry , or replacing an existing entry with a new one . Getting all cache entries as a Map \u00b6 To get a copy of the current cache entries as a Map : val cache = Cache . Builder () . build < Long , String > () cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) assertThat ( cache . asMap ()) . isEqualTo ( mapOf ( 1L to \"dog\" , 2L to \"cat\" )) Note that calling asMap() has no effect on the access expiry of the cache. Deleting cache entries \u00b6 Cache entries can also be deleted explicitly. To delete a cache entry for a given key: val cache = Cache . Builder (). build < Long , String > () cache . put ( 1 , \"dog\" ) cache . invalidate ( 1 ) assertThat ( cache . get ( 1 )). isNull () To delete all entries in the cache: cache . invalidateAll () Unit testing cache expirations \u00b6 To test logic that depends on cache expiration, pass in a FakeTimeSource when building a Cache so you can programmatically advance the reading of the time source: @Test fun cacheEntryEvictedAfterExpiration () { private val fakeTimeSource = FakeTimeSource () val cache = Cache . Builder () . fakeTimeSource ( fakeTimeSource ) . expireAfterWrite ( 1. minutes ) . build < Long , String > () cache . put ( 1 , \"dog\" ) // just before expiry fakeTimeSource += 1. minutes - 1. nanoseconds assertThat ( cache . get ( 1 )) . isEqualTo ( \"dog\" ) // now expires fakeTimeSource += 1. nanoseconds assertThat ( cache . get ( 1 )) . isNull () } Credits \u00b6 The library was ported from a kotlin / JVM cache which I contributed to dropbox/Store to help unblock Store\u2019s multiplatform support ( it was reverted before the 1.0 release as multiplatform wasn\u2019t a priority). Many thanks to Store\u2019s owners and contributors for reviewing and improving the original implementation. Native concurrency support of the library is powered by touchlab/Stately . Many thanks to Stately\u2019s authors and contributors for the great library. License \u00b6 Copyright 2021 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#cache4k","text":"In-memory Cache for Kotlin Multiplatform. Work in progress. cache4k provides a simple in-memory key-value cache for Kotlin Multiplatform , with support for time-based (expiration) and size-based evictions. The following targets are currently supported: jvm js iosX64 iosArm64 macosX64 watchosArm32 watchosArm64 tvosX64 tvosArm64","title":"cache4k"},{"location":"#download","text":"Dependencies are hosted on Maven Central .","title":"Download"},{"location":"#android","text":"dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) }","title":"Android"},{"location":"#multiplatform","text":"kotlin { sourceSets { commonMain { dependencies { implementation ( \"io.github.reactivecircus.cache4k:cache4k:x.y.z\" ) } } } }","title":"Multiplatform"},{"location":"#usage","text":"","title":"Usage"},{"location":"#writing-and-reading-cache-entries","text":"To create a new Cache instance using Long for the key and String for the value: val cache = Cache . Builder (). build < Long , String > () To start writing entries to the cache: cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) To read a cache entry by key: cache . get ( 1 ) // returns \"dog\" cache . get ( 2 ) // returns \"cat\" cache . get ( 3 ) // returns null To overwrite an existing cache entry: cache . put ( 1 , \"dog\" ) cache . put ( 1 , \"bird\" ) cache . get ( 1 ) // returns \"bird\"","title":"Writing and reading cache entries"},{"location":"#cache-loader","text":"Cache provides an API for getting cached value by key and using the provided loader: suspend () -> Value lambda to compute and cache the value automatically if none exists. runBlockingTest { val cache = Cache . Builder (). build < Long , User > () val userId = 1L val user = cache . get ( userId ) { fetchUserById ( userId ) // potentially expensive call (might be a suspend function) } // value successfully computed by the loader will be cached automatically assertThat ( user ). isEqualTo ( cache . get ( userId )) } Any exceptions thrown by the loader will be propagated to the caller of this function.","title":"Cache loader"},{"location":"#expirations-and-evictions","text":"By default, Cache has an unlimited number of entries which never expire. But a cache can be configured to support both time-based expirations and size-based evictions .","title":"Expirations and evictions"},{"location":"#time-based-expiration","text":"Expiration time can be specified for entries in the cache.","title":"Time-based expiration"},{"location":"#expire-after-access","text":"To set the maximum time an entry can live in the cache since the last access (also known as ** time-to-idle**), where \u201caccess\u201d means reading the cache , adding a new cache entry , or ** replacing an existing entry with a new one**: val cache = Cache . Builder () . expireAfterAccess ( 24. hours ) . build < Long , String > () An entry in this cache will be removed if it has not been read or replaced after 24 hours since it\u2019s been written into the cache.","title":"Expire after access"},{"location":"#expire-after-write","text":"To set the maximum time an entry can live in the cache since the last write (also known as ** time-to-live**), where \u201cwrite\u201d means adding a new cache entry or replacing an existing entry with a new one : val cache = Cache . Builder () . expireAfterWrite ( 30. minutes ) . build < Long , String > () An entry in this cache will be removed if it has not been replaced after 30 minutes since it\u2019s been written into the cache. Note that cache entries are not removed immediately upon expiration at exact time. Expirations are checked in each interaction with the cache .","title":"Expire after write"},{"location":"#size-based-eviction","text":"To set the maximum number of entries to be kept in the cache: val cache = Cache . Builder () . maximumCacheSize ( 100 ) . build < Long , String > () Once there are more than 100 entries in this cache, the least recently used one will be removed, where \u201cused\u201d means reading the cache , adding a new cache entry , or replacing an existing entry with a new one .","title":"Size-based eviction"},{"location":"#getting-all-cache-entries-as-a-map","text":"To get a copy of the current cache entries as a Map : val cache = Cache . Builder () . build < Long , String > () cache . put ( 1 , \"dog\" ) cache . put ( 2 , \"cat\" ) assertThat ( cache . asMap ()) . isEqualTo ( mapOf ( 1L to \"dog\" , 2L to \"cat\" )) Note that calling asMap() has no effect on the access expiry of the cache.","title":"Getting all cache entries as a Map"},{"location":"#deleting-cache-entries","text":"Cache entries can also be deleted explicitly. To delete a cache entry for a given key: val cache = Cache . Builder (). build < Long , String > () cache . put ( 1 , \"dog\" ) cache . invalidate ( 1 ) assertThat ( cache . get ( 1 )). isNull () To delete all entries in the cache: cache . invalidateAll ()","title":"Deleting cache entries"},{"location":"#unit-testing-cache-expirations","text":"To test logic that depends on cache expiration, pass in a FakeTimeSource when building a Cache so you can programmatically advance the reading of the time source: @Test fun cacheEntryEvictedAfterExpiration () { private val fakeTimeSource = FakeTimeSource () val cache = Cache . Builder () . fakeTimeSource ( fakeTimeSource ) . expireAfterWrite ( 1. minutes ) . build < Long , String > () cache . put ( 1 , \"dog\" ) // just before expiry fakeTimeSource += 1. minutes - 1. nanoseconds assertThat ( cache . get ( 1 )) . isEqualTo ( \"dog\" ) // now expires fakeTimeSource += 1. nanoseconds assertThat ( cache . get ( 1 )) . isNull () }","title":"Unit testing cache expirations"},{"location":"#credits","text":"The library was ported from a kotlin / JVM cache which I contributed to dropbox/Store to help unblock Store\u2019s multiplatform support ( it was reverted before the 1.0 release as multiplatform wasn\u2019t a priority). Many thanks to Store\u2019s owners and contributors for reviewing and improving the original implementation. Native concurrency support of the library is powered by touchlab/Stately . Many thanks to Stately\u2019s authors and contributors for the great library.","title":"Credits"},{"location":"#license","text":"Copyright 2021 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 0.3.0 \u00b6 Changed \u00b6 Change fun newBuilder() to operator fun invoke() - #7 . Compile with Kotlin 1.5.21. 0.2.0 \u00b6 Changed \u00b6 Support Kotlin 1.5.0. Stately to 1.1.7. 0.1.1 \u00b6 Changed \u00b6 Disable IR. 0.1.0 \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changed","text":"Change fun newBuilder() to operator fun invoke() - #7 . Compile with Kotlin 1.5.21.","title":"Changed"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changed_1","text":"Support Kotlin 1.5.0. Stately to 1.1.7.","title":"Changed"},{"location":"changelog/#011","text":"","title":"0.1.1"},{"location":"changelog/#changed_2","text":"Disable IR.","title":"Changed"},{"location":"changelog/#010","text":"Initial release.","title":"0.1.0"}]}